name: ğŸš€ Deploy to GCP e2-micro

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [ closed ]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  VM_NAME: ${{ secrets.GCP_VM_NAME }}
  VM_ZONE: ${{ secrets.GCP_VM_ZONE }}
  VM_USER: ${{ secrets.GCP_VM_USER }}
  VM_IP: ${{ secrets.GCP_VM_IP }}

jobs:
  # Job 1: Testes (roda sempre)
  test:
    name: ğŸ§ª Testes e ValidaÃ§Ã£o
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“¥ Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: ğŸ Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: ğŸ“¦ Instalar dependÃªncias
      run: |
        pip install -r requirements.txt
    
    - name: ğŸ” Validar sintaxe Python
      run: |
        python -m py_compile app_secure.py
        python -m py_compile models.py
        python -m py_compile auth.py
        python -m py_compile forms.py
    
    - name: ğŸ”§ Validar configuraÃ§Ãµes Docker
      run: |
        docker --version
        docker compose version
        docker compose config
    
    - name: âœ… Validar templates
      run: |
        find templates -name "*.html" -exec echo "Validando {}" \;
        # Verificar se templates principais existem
        test -f templates/auth/login.html
        test -f templates/base.html
        test -f templates/index.html
    
    - name: ğŸ” Validar configuraÃ§Ãµes de seguranÃ§a
      run: |
        # Verificar se arquivo .env.example existe e tem as variÃ¡veis necessÃ¡rias
        test -f .env.example
        grep -q "SECRET_KEY" .env.example
        grep -q "MONGODB_URI" .env.example
        grep -q "FLASK_ENV" .env.example

  # Job 2: Deploy (sÃ³ roda se testes passaram e Ã© push para main)
  deploy:
    name: ğŸš€ Deploy para GCP
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ“¥ Checkout cÃ³digo
      uses: actions/checkout@v4
    
    - name: ğŸ” Configurar autenticaÃ§Ã£o GCP
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}
    
    - name: âš™ï¸ Configurar gcloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}
    
    - name: ğŸ”‘ Configurar SSH
      run: |
        # Criar diretÃ³rio SSH se nÃ£o existir
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Configurar chave SSH (sobrescrever se existir)
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/gcp_deploy
        chmod 600 ~/.ssh/gcp_deploy
        
        # Adicionar host conhecido (evitar duplicatas)
        ssh-keyscan -H ${{ secrets.GCP_VM_IP }} > ~/.ssh/known_hosts_temp
        if [ -f ~/.ssh/known_hosts ]; then
          # Remover entrada existente e adicionar nova
          grep -v "${{ secrets.GCP_VM_IP }}" ~/.ssh/known_hosts > ~/.ssh/known_hosts_temp2 || true
          cat ~/.ssh/known_hosts_temp2 ~/.ssh/known_hosts_temp > ~/.ssh/known_hosts
          rm -f ~/.ssh/known_hosts_temp2
        else
          mv ~/.ssh/known_hosts_temp ~/.ssh/known_hosts
        fi
        rm -f ~/.ssh/known_hosts_temp
        chmod 644 ~/.ssh/known_hosts
        
        echo "âœ… SSH configurado com seguranÃ§a"
    
    - name: ğŸ¥ Verificar saÃºde da VM
      run: |
        echo "ğŸ” Verificando se VM estÃ¡ acessÃ­vel..."
        ssh -i ~/.ssh/gcp_deploy -o ConnectTimeout=30 ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          echo 'âœ… VM acessÃ­vel'
          echo 'ğŸ“Š Status da VM:'
          echo '  Uptime: $(uptime -p)'
          echo '  MemÃ³ria: $(free -h | grep Mem | awk "{print \$3\"/\"\$2}")'
          echo '  Disco: $(df -h / | tail -1 | awk "{print \$5}")'
        "
    
    - name: ğŸ›‘ Parar aplicaÃ§Ã£o atual
      run: |
        echo "ğŸ›‘ Parando aplicaÃ§Ã£o atual..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR || { echo 'ğŸ“ DiretÃ³rio nÃ£o existe, criando...'; mkdir -p \$PROJECT_DIR; cd \$PROJECT_DIR; }
          if [ -f docker-compose.yml ]; then
            echo 'â¹ï¸ Parando containers...'
            docker compose down || echo 'âš ï¸ Nenhum container rodando'
          else
            echo 'ğŸ“‹ Primeira execuÃ§Ã£o - sem containers para parar'
          fi
        "
    
    - name: ğŸ“¦ Fazer backup da versÃ£o atual
      run: |
        echo "ğŸ’¾ Criando backup..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          BACKUP_DIR='backups/deploy_$(date +%Y%m%d_%H%M%S)'
          mkdir -p \$BACKUP_DIR
          
          # Backup de arquivos importantes
          [ -f users.json ] && cp users.json \$BACKUP_DIR/
          [ -f .env ] && cp .env \$BACKUP_DIR/
          [ -d uploads ] && cp -r uploads \$BACKUP_DIR/
          
          echo 'âœ… Backup criado em' \$BACKUP_DIR
          
          # Manter apenas os 5 backups mais recentes
          ls -dt backups/deploy_* | tail -n +6 | xargs rm -rf
        "
    
    - name: ğŸ“¤ Enviar cÃ³digo atualizado (alternativa sem rsync)
      run: |
        echo "ğŸ“¤ Enviando arquivos..."
        
        # Criar arquivo temporÃ¡rio compactado excluindo arquivos desnecessÃ¡rios
        echo "ğŸ“¦ Preparando arquivos para envio..."
        
        # Criar diretÃ³rio temporÃ¡rio para arquivos limpos
        TEMP_DIR=$(mktemp -d)
        echo "ğŸ“ Criando pacote limpo em: $TEMP_DIR"
        
        # Copiar arquivos necessÃ¡rios para o diretÃ³rio temporÃ¡rio
        # Usar find + cp para sistemas sem rsync
        echo "ğŸ“‹ Copiando arquivos necessÃ¡rios..."
        find . -type f \
            ! -path './.git*' \
            ! -path './.github*' \
            ! -path './__pycache__*' \
            ! -path './venv*' \
            ! -path './uploads*' \
            ! -path './logs*' \
            ! -path './backups*' \
            ! -path './.pytest_cache*' \
            ! -path './node_modules*' \
            ! -name '*.pyc' \
            ! -name '.env' \
            ! -name 'users.json' \
            ! -name '*.log' \
            ! -name 'session_*.json' \
            ! -name 'deploy_package.tar.gz' \
            -exec cp --parents {} $TEMP_DIR/ \;
        
        # Criar arquivo compactado do diretÃ³rio limpo
        echo "ğŸ—œï¸ Compactando arquivos..."
        tar -czf deploy_package.tar.gz -C $TEMP_DIR .
        
        # Verificar se o pacote foi criado com sucesso
        if [ ! -f deploy_package.tar.gz ]; then
            echo "âŒ Erro: Pacote nÃ£o foi criado!"
            rm -rf $TEMP_DIR
            exit 1
        fi
        
        # Limpar diretÃ³rio temporÃ¡rio
        rm -rf $TEMP_DIR
        echo "âœ… Pacote criado: $(ls -lh deploy_package.tar.gz | awk '{print $5}')"
        
        # Enviar arquivo compactado
        echo "ğŸš€ Enviando pacote..."
        scp -i ~/.ssh/gcp_deploy -o StrictHostKeyChecking=no \
            deploy_package.tar.gz \
            ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }}:/tmp/
        
        # Extrair no servidor
        echo "ğŸ“‚ Extraindo arquivos na VM..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          # Usar diretÃ³rio especÃ­fico do usuÃ¡rio github-actions
          PROJECT_DIR=/home/github-actions/analise-cartao
          
          # Criar diretÃ³rio se nÃ£o existir
          mkdir -p \$PROJECT_DIR
          cd \$PROJECT_DIR
          
          echo 'ğŸ“ Trabalhando no diretÃ³rio:' \$(pwd)
          
          # Fazer backup dos arquivos importantes antes de extrair
          mkdir -p temp_backup
          [ -f .env ] && cp .env temp_backup/
          [ -f users.json ] && cp users.json temp_backup/
          [ -d uploads ] && cp -r uploads temp_backup/ 2>/dev/null || true
          
          # Limpar diretÃ³rio atual (exceto backups e arquivos importantes)
          find . -maxdepth 1 -type f ! -name '.env' ! -name 'users.json' -delete 2>/dev/null || true
          find . -maxdepth 1 -type d ! -name '.' ! -name 'uploads' ! -name 'logs' ! -name 'backups' ! -name 'ssl' ! -name 'temp_backup' -exec rm -rf {} + 2>/dev/null || true
          
          # Extrair novos arquivos
          tar -xzf /tmp/deploy_package.tar.gz
          
          # Restaurar arquivos importantes
          [ -f temp_backup/.env ] && cp temp_backup/.env .
          [ -f temp_backup/users.json ] && cp temp_backup/users.json .
          [ -d temp_backup/uploads ] && cp -r temp_backup/uploads . 2>/dev/null || true
          
          # Limpar
          rm -rf temp_backup /tmp/deploy_package.tar.gz
          
          echo 'âœ… Arquivos extraÃ­dos e configurados'
        "
        
        # Remover arquivo temporÃ¡rio local
        rm -f deploy_package.tar.gz
        
        echo "âœ… Arquivos enviados"
    
    - name: âš™ï¸ Configurar ambiente na VM
      run: |
        echo "âš™ï¸ Configurando ambiente..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          
          # Criar diretÃ³rios necessÃ¡rios
          mkdir -p uploads logs ssl backups
          
          # Configurar .env se nÃ£o existir
          if [ ! -f .env ]; then
            echo 'ğŸ“ Criando arquivo .env...'
            cat > .env << 'EOF'
        FLASK_ENV=production
        SECRET_KEY=${{ secrets.SECRET_KEY }}
        MONGODB_URI=${{ secrets.MONGODB_URI }}
        REGISTRATION_ENABLED=false
        SESSION_COOKIE_SECURE=false
        SESSION_COOKIE_HTTPONLY=true
        SESSION_COOKIE_SAMESITE=Lax
        PORT=5000
        HOST=0.0.0.0
        EOF
          else
            echo 'âœ… Arquivo .env jÃ¡ existe'
          fi
          
          # Verificar se usuÃ¡rio padrÃ£o existe
          if [ ! -f users.json ]; then
            echo 'ğŸ‘¤ Arquivo users.json nÃ£o existe - serÃ¡ criado no primeiro acesso'
          fi
          
          echo 'âœ… Ambiente configurado'
        "
    
    - name: ğŸ”§ Corrigir permissÃµes Docker
      run: |
        echo "ğŸ”§ Corrigindo permissÃµes do Docker..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          # Adicionar usuÃ¡rio ao grupo docker se necessÃ¡rio
          if ! groups \$USER | grep -q '\bdocker\b'; then
            echo 'ğŸ“ Adicionando usuÃ¡rio ao grupo docker...'
            sudo usermod -aG docker \$USER
            echo 'âš ï¸ UsuÃ¡rio adicionado ao grupo docker'
          fi
          
          # Verificar se o Docker daemon estÃ¡ rodando
          if ! docker info >/dev/null 2>&1; then
            echo 'ğŸš€ Iniciando Docker daemon...'
            sudo systemctl start docker
            sudo systemctl enable docker
          fi
          
          # Verificar permissÃµes do socket
          if [ -S /var/run/docker.sock ]; then
            echo 'ğŸ” Verificando permissÃµes do socket Docker...'
            ls -la /var/run/docker.sock
            # Corrigir permissÃµes se necessÃ¡rio
            sudo chmod 666 /var/run/docker.sock
          fi
          
          echo 'âœ… PermissÃµes Docker verificadas'
        "

    - name: ğŸ³ Otimizar Docker para e2-micro
      run: |
        echo "ğŸ³ Otimizando configuraÃ§Ã£o Docker..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          
          # Criar docker-compose otimizado para e2-micro
          cat > docker-compose.yml << 'EOF'
        services:
          web:
            build: .
            container_name: analise_cartao_web
            ports:
              - '5000:5000'
            environment:
              - FLASK_ENV=production
            env_file:
              - .env
            volumes:
              - ./uploads:/app/uploads
              - ./logs:/app/logs
              - ./users.json:/app/users.json
            restart: unless-stopped
            deploy:
              resources:
                limits:
                  memory: 300M
                reservations:
                  memory: 200M
            networks:
              - analise_cartao_network
        
          nginx:
            image: nginx:alpine
            container_name: analise_cartao_nginx
            ports:
              - '80:80'
              - '443:443'
            volumes:
              - ./nginx.conf:/etc/nginx/nginx.conf:ro
              - ./ssl:/etc/nginx/ssl:ro
              - ./static:/var/www/static:ro
            restart: unless-stopped
            depends_on:
              - web
            deploy:
              resources:
                limits:
                  memory: 50M
                reservations:
                  memory: 30M
            networks:
              - analise_cartao_network
        
        networks:
          analise_cartao_network:
            driver: bridge
        EOF
          
          # Otimizar Dockerfile para e2-micro
          cat > Dockerfile << 'EOF'
        FROM python:3.11-slim
        
        # OtimizaÃ§Ãµes para pouca memÃ³ria
        ENV PYTHONUNBUFFERED=1
        ENV PYTHONDONTWRITEBYTECODE=1
        ENV PIP_NO_CACHE_DIR=1
        ENV PIP_DISABLE_PIP_VERSION_CHECK=1
        
        # Instalar dependÃªncias do sistema (mÃ­nimas)
        RUN apt-get update && apt-get install -y --no-install-recommends \
            curl \
            && rm -rf /var/lib/apt/lists/* \
            && apt-get clean
        
        # Criar usuÃ¡rio nÃ£o-root
        RUN groupadd -r appuser && useradd -r -g appuser appuser
        
        # Criar diretÃ³rios
        RUN mkdir -p /app/uploads /app/logs && chown -R appuser:appuser /app
        
        WORKDIR /app
        
        # Copiar requirements primeiro (cache layer)
        COPY requirements.txt .
        
        # Instalar dependÃªncias Python (otimizado para memÃ³ria)
        RUN pip install --no-cache-dir -r requirements.txt
        
        # Copiar cÃ³digo
        COPY . .
        RUN chown -R appuser:appuser /app
        
        USER appuser
        
        EXPOSE 5000
        
        # Health check leve
        HEALTHCHECK --interval=60s --timeout=10s --start-period=30s --retries=3 \
            CMD curl -f http://localhost:5000/auth/login || exit 1
        
        # Usar gunicorn com configuraÃ§Ã£o otimizada para e2-micro
        CMD [\"gunicorn\", \"--bind\", \"0.0.0.0:5000\", \"--workers\", \"1\", \"--threads\", \"2\", \"--timeout\", \"120\", \"--max-requests\", \"500\", \"--preload\", \"app_secure:app\"]
        EOF
          
          echo 'âœ… ConfiguraÃ§Ã£o Docker otimizada'
        "
    
    - name: ğŸ”§ Configurar SSL automÃ¡tico
      run: |
        echo "ğŸ”’ Configurando SSL..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          
          # Script para configurar SSL automaticamente
          cat > setup_ssl.sh << 'EOF'
        #!/bin/bash
        
        # Verificar se certbot estÃ¡ instalado
        if ! command -v certbot &> /dev/null; then
            echo 'ğŸ“¦ Instalando Certbot...'
            sudo apt update
            sudo apt install -y certbot
        fi
        
        # Criar certificado auto-assinado temporÃ¡rio
        if [ ! -f ssl/cert.pem ]; then
            echo 'ğŸ” Criando certificado auto-assinado temporÃ¡rio...'
            mkdir -p ssl
            sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout ssl/key.pem \
                -out ssl/cert.pem \
                -subj '/C=BR/ST=SP/L=SaoPaulo/O=AnalisadorPDF/CN=localhost'
            sudo chown -R github-actions:github-actions ssl/
        fi
        
        echo 'âœ… SSL configurado (certificado auto-assinado)'
        echo 'ğŸ’¡ Para domÃ­nio real, execute: sudo certbot certonly --standalone -d seu-dominio.com'
        EOF
          
          chmod +x setup_ssl.sh
          ./setup_ssl.sh
        "
    
    - name: ğŸš€ Construir e iniciar aplicaÃ§Ã£o
      run: |
        echo "ğŸš€ Iniciando aplicaÃ§Ã£o..."
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          
          # Verificar se Docker estÃ¡ funcionando
          echo 'ğŸ” Verificando Docker...'
          if ! docker info >/dev/null 2>&1; then
            echo 'âŒ Docker nÃ£o estÃ¡ funcionando, tentando corrigir...'
            sudo systemctl restart docker
            sleep 5
            if ! docker info >/dev/null 2>&1; then
              echo 'âŒ Docker ainda nÃ£o estÃ¡ funcionando'
              exit 1
            fi
          fi
          echo 'âœ… Docker funcionando corretamente'
          
          # Limpar imagens antigas para economizar espaÃ§o
          docker system prune -f
          
          # Construir com cache otimizado
          echo 'ğŸ”¨ Construindo imagem...'
          docker compose build --no-cache web
          
          # Iniciar serviÃ§os
          echo 'â–¶ï¸ Iniciando serviÃ§os...'
          docker compose up -d
          
          # Aguardar inicializaÃ§Ã£o
          echo 'â³ Aguardando inicializaÃ§Ã£o...'
          sleep 30
          
          # Verificar status
          echo 'ğŸ“Š Status dos containers:'
          docker compose ps
          
          echo 'ğŸ‰ Deploy concluÃ­do!'
        "
    
    - name: ğŸ” Verificar deploy
      run: |
        echo "ğŸ” Verificando deploy..."
        
        # Aguardar um pouco mais para garantir que tudo estÃ¡ funcionando
        sleep 15
        
        # Testar endpoint de saÃºde
        if curl -f -m 10 http://${{ secrets.GCP_VM_IP }}/auth/login > /dev/null 2>&1; then
          echo "âœ… AplicaÃ§Ã£o respondendo corretamente!"
        else
          echo "âŒ AplicaÃ§Ã£o nÃ£o estÃ¡ respondendo"
          
          # Debug: verificar logs
          ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
            cd /home/github-actions/analise-cartao
            echo 'ğŸ” Logs da aplicaÃ§Ã£o:'
            docker compose logs --tail=20 web
            echo 'ğŸ” Logs do Nginx:'
            docker compose logs --tail=10 nginx
          "
          exit 1
        fi
    
    - name: ğŸ“Š Status final
      run: |
        echo "ğŸ“Š Status final do deploy:"
        ssh -i ~/.ssh/gcp_deploy ${{ secrets.GCP_VM_USER }}@${{ secrets.GCP_VM_IP }} "
          PROJECT_DIR=/home/github-actions/analise-cartao
          cd \$PROJECT_DIR
          echo 'ğŸ³ Containers:'
          docker compose ps
          echo ''
          echo 'ğŸ’¾ Uso de memÃ³ria:'
          free -h
          echo ''
          echo 'ğŸ’¿ Uso de disco:'
          df -h /
          echo ''
          echo 'ğŸŒ Acesso:'
          echo '  HTTP:  http://${{ secrets.GCP_VM_IP }}'
          echo '  HTTPS: https://${{ secrets.GCP_VM_IP }} (certificado auto-assinado)'
          echo '  Login: admin / admin123'
          echo ''
          echo 'âœ… Deploy realizado com sucesso!'
        "

  # Job 3: NotificaÃ§Ã£o (roda sempre apÃ³s deploy, success ou failure)
  notify:
    name: ğŸ“¢ NotificaÃ§Ã£o
    needs: [test, deploy]
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ“¢ Notificar resultado
      run: |
        if [ "${{ needs.deploy.result }}" == "success" ]; then
          echo "ğŸ‰ Deploy realizado com sucesso!"
          echo "ğŸŒ AplicaÃ§Ã£o disponÃ­vel em: http://${{ secrets.GCP_VM_IP }}"
          echo "ğŸ‘¤ Login padrÃ£o: admin / admin123"
        else
          echo "âŒ Deploy falhou!"
          echo "ğŸ” Verifique os logs do workflow para mais detalhes"
        fi
